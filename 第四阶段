
HTTPRequest与HTTPresponse

一、

1、互联网两台机器之间通行：ip、端口、协议
	- 协议
		- HTTP  （80）
		- HTTPS  (443) 

2、浏览器输入URL一回车返回页面发生了什么？
	- 域名 -> DNS解析 -->ip地址 -> 找到服务端 ->服务端返回消息 -> 浏览器
	- 浏览器 <-> 服务器
	- 服务器把 写好的HTML页面，返回给浏览器，浏览器按照HTML格式渲染
	「

	」

3、请求和相应
	- HTTP协议的特点：
		- 浏览器给服务端发消息的过程叫请求（request）
		- 服务器给浏览器回复消息的过程叫响应（response）
		
	- 请求和相应的消息都必须遵循一个固定的格式

4、python中Web框架分类
	- a、收发socket消息，按照HTTP协议解析消息   Web服务程序 wsgiref（模块）、gunicorn、uWSGI
	- b、字符串替换，用来实现动态网页								
	- c、业务逻辑处理							Web应用程序

	1- 自己实现abc的
		- Tronado  
	2- 自己实现bc使用别人的a
		- Django
	3- 自己实现c使用别人的ab
		- Flask
5、Web服务程序  <-  WSGI协议  -> Web应用程序


5.5、Django版本
	- LTS版本 （Long Team support）

6、创建第一个Django项目
	
	安装：  pip install django==1.11.11
			pip install django==1.11.11 -i 指定源 

	- 1、命令行  Django-admin startproject first_Django
	- 2、Pycharm创建
		- file -> new Project ->右侧选Django -> 选好路径 ->选好环境 -> 名字app -> 在新的窗口打开文件
	- 3、启动项目
		- 命令行启动(切换到项目的根目录)
			- python manage.py runserver 127.0.0.1:8090(改端口这样指定)
		- pycharm启动
			- 框中选项为项目名->让后点击启动按钮（右上角）（如果想改就在旁边点编辑-就可以改端口等）

	- 目录介绍
		- 和项目名一样的是根目录
		- 
	---------------------
	- 先来一份自己的理解
		- 1、（与我们所创建文件名一致的目录）根目录
			- manage.py 
				- 这是启动文件，程序入口。
			- settings.py
				- 包含了项目的一些设置，包括数据库信息、调试标志以及其他的一些工作的变量。
				- BASE_DIR = 项目的根目录
				- TIMELATES = templates去哪找
				- DATABASES = 数据库
				- 静态文件配置
					- STATIC_URL = '/static/' # 请别名
					- STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),] # 配置去static下找静态文件
			- urls.py
				- 路径与视图函数的映射关系


		- 2、templates - 这个文件夹存放的是HTML文件
		- 3、static - 这个文件夹是存放静态文件，需要自己配置，用的时候的导入时用 
		     /static/.. 来引入所用的静态文件
		     	# Static files (CSS, JavaScript, Images)
				# https://docs.djangoproject.com/en/1.11/howto/static-files/

				# 这个static就代表了下面的路径 （寻找的时候就是去static下面的路径中挨个找）
				STATIC_URL = '/static/'  # 起别名， HTML中找静态文件都要以这个别名开始  (找到别名后就去这个别名的配置比文件中找对应的文件)

				# 这个常量是固定格式
				STATICFILES_DIRS = [
				    os.path.join(BASE_DIR, 'static'),
				]
	
7、项目流程
	- 先输入url
	- 去Django的urls中匹配urlpatterns->匹配上调用后面匹配的函数->去找对应的函数
	- 找到执行的函数->Django调用要执行的函数给函数传一个request参数，所有和请求相关的数据 都在request中
	- render去templates文件夹找到HTML文件，打开读取内容，按照http响应格式给浏览器返回读取的内容
	- 浏览器收到Django返回的响应消息，按照HTML格式显示这个消息



其他：
	- from django.shortcuts import HttpResponse, render
		- HttpResponse (封装了协议头等-有待商议)
		- render （渲染）

	- 文件的上传（form表单的提交， 必须用POST）
		def index(request):
		    print(request.GET)
		    print(request.POST)
		    print(request.FILES)

		    for item in request.FILES:
		        fileobj = request.FILES.get(item)
		        f = open('upload/%s' % fileobj.name, 'wb')
		        item_file = fileobj.chunks()
		        for line in item_file:
		            f.write(line)
		        f.close()

		    return HttpResponse("成功")
 	- form表单上传文件时需要注意的事情
 		- action 最后加 /  或者 修改settings:APPEND_SLASH=False
 		- method 必须为post 
 		- enctype = “multipart/form-data” 必须写

 	- 指定IP登录
 		默认IP和端口
		    python manage.py runserver
		指定端口：
		    python manage.py runserver 192.168.12.12:8080
		此时会报错，我们需要修改配置文件：
		修改settings.py，将192.168.12.12添加到ALLOWED_HOSTS中
		ALLOWED_HOSTS=['172.31.169.182','127.0.0.1','192.168.1.50','192.168.1.115']
		也可以将ALLOWED_HOSTS改成通配符 *
		ALLOWED_HOSTS = ["*"]



二、

1、表单的提交（登录）
	- submit -> action -> 对应函数（参数request（数据信息））-> 处理
		注意：必须要有name属性 *****
	- 提交到服务器的是QueryDict对象，可以通过get获取值


2、form表单提交的三个要素
	- form标签必须有action和method属性
	- 所有获取用户输入的标签必须放在form表单中，必须有name属性（input,select,textarea）
	- 必须有submit按钮


3、redirect 跳转,改变方向
	- 跳转到别人的页面，自己的页面
		- 跳转比人页面
			redirect("https://baidu.com")
		- 跳转自己页面
			redirect("/相对路径/")

4、Django必会三件套  from django.shortcuts import
	- HttpRequest	返回一个指定的字符串	
		(把字符串转为而二进制，然后按照HTTP响应格式要求返回)
	- render   		返回一个HTML文件		HTML文件 模板语言
		（第一个参数为request， 第二个参数为render的页面，第三个参数为字典，将render页面中的特殊符号替换{字典的键为html的变量，值为给页面展示的值}）
	- redirect		跳转   		路径     URL
		（redirect(/index/) -> 在同网站不同地址间跳转（返回重定向响应）
		  redirect('https://wwww.baidu.com') -> 访问指定的网址）

5、request相关属性 （所有和请求相关的数据都封装在request对象中）
	- POST      取到POST提交的数据（form表单提交的）
	- GET 		取到URL携带的参数
	- method	当前这次请求的方法（GET/POST）

6、Django的模板语言
	{{ 变量 }}

7、Django项目project
	- app（应用） -> 不同的功能放在不同的app中
		- 命令 ：
			- 创建app  
				python manage.py startapp app01(应用名)	
			- 注册app(告诉Django创建了app)
				在settings中的 INSTALLED_APPS 添加新创建的app（app名.apps.apps中的类）


8、程序链接mysql
	- 使用pymysql模块
		- 导入pymysql
		- 创建链接
		- 获取执行命令的游标
		- 用游标执行SQL语句
		- 获取SQL语句的执行结果
		- 关闭游标
		- 关闭链接

	- ORM - Object Relationship Mapping （对象关系映射）
	- 这时，创建一种工具 帮助我们翻译SQL语句（ORM - 面向对象的思想）
		- 优点
			- 开发效率高
			- 开发不用直接写SQL语句
		- 缺点
			- 执行效率低

	- 对应关系
		ORM 		DB

		类			数据表
		属性			字段
		对象			数据行



	- Django项目project
		- app（应用） -> 不同的功能放在不同的app中
			- 命令 ：
				- 创建app  
					python manage.py startapp app01(应用名)	
				- 告诉Django创建了app
					在settings中的 INSTALLED_APPS 添加新创建的app（app名.apps.apps中的类）
	- Django中ORM使用
		- 用处：
			- 操作数据表
			- 操作数据行
		- 使用
			- 手动创建数据库
			- 告诉Django连那个数据库
				- settings中配置DATABASES
				DATABASES = {
				    'default': {
				        'ENGINE': 'django.db.backends.mysql',  # 链接数据库的类型
				        'NAME': 'db',  # 链接数据库的名字
				        'HOST': '127.0.0.1',  # 数据库主机地址
				        'PORT': 3306,  # 数据库端口
				        'USER': 'root',  # 数据库用户名
				        'PASSWORD': '123456',  # 数据库密码
				    }
				}

			- 用什么链接数据库？
				- 利用第三方包 pymysql 和 MySQLdb(py2中)
				- 告诉Django用pymysql模块代替默认的MySQLdb链接MySQL数据库
					和settings.py同级的__init__.py文件，写上
					import pymysql
					pymysql.install_as_MySQLdb()

			- 在app/models.py的文件中创建类
				类必须继承models.Model


			- 两个命令
				- python manage.py makemigrations -> 生成脚本文件存放在app文件夹应用下的migrations文件夹中（相当于拿个小本本把models.py的变更记录下来）
				- python manage.py migrate -> 把上面的变更记录翻译成sql语句，去数据库执行

			- ORM查询
				modules.User.object.filter(email='', pwd='')


三、

1、图书管理系统
	- 出版社
		id name
	- 作者
		id name
	- 书
		id title 出版社_id
	- 书_作者关系表
		id 书_id 作者_id

2.ORM增删改查
	models.表名.object./filter()/all()/create()
		- filter()  按照指定内容筛选 （字段=值）				放回一个列表
		- all()		查询出数据库所有信息（属性order_by(id)排序） 返回一个列表
		- create()	向数据库添加信息 （字段=值）创建一个对象		返回一个创建的对象
		- get()		返回一个对象
		- filter(id='').delete()	删除
		- obj = 类名.object.get(id='')
			obj.name = '新值' 	修改对象的属性（修改数据行某个字段的值）
			obj.save()			把修改同步到数据库

3、模板语言
	- for循环
		{% for i in ret %}
			{{ i }}
			{{ forloop.counter }}  	for循环从1开始计数
			{{ forloop.counter0 }}	for循环从0开始计数
		{% endfor %}


总结：ORM的 查、增、删、改

	- 查
		- client
			- 有一个展示页面（xxx_show.html）
				- 这一个页面一输入执行后，get请求向server端发送
			- 这个展示页面有添加按钮、删除按钮、编辑按钮
			- 这个页面要展示内容
				- 是server端收到第一次的get请求而做出的response
				- 页面需要用到模板语言for循环
					{% for i in result %}
						{{ i.xx }}  #获取result中的每个值（也就是server端传来的东西） 
					{% endfor %}
		- server
			- 首先会收到一开始访问页面的GET请求
			- 收到请求后到urls中找匹配的url，找到对应的url后，执行后面所对应的视图函数
			- 找到对应的视图函数后就行执行响应的逻辑，也就是拿出数据库中的东西，发送给server
				- 可以通过 models.表名.objects.all() 获取数据库这张表中的所有内容（返回一个列表）
					- data = models.表名.objects.all()
				- 拿到数据后将这些数据给展示（通过render方法）
					- return render(request, 'xxx_show.html', 'result':data)
					 #这里的result就是要传给xxx_show.html的一个变量（其中的值就是data的数据）

	- 增
		- client
			- 有一个展示页面（xxx_show.html）
			- 这个页面有一个添加按钮（a标签）
				- 点击这个按钮（a标签），client会发送一个get请求，会用a标签的路径去访问server
				- 这时会跳转到a标签所指的url(/add_xxx/)
				- 然后server给出response（这里的业务逻辑就都得在server）
			- 第一次get请求server会返回一个add_xxx.html页面
				- 这是可以添加数据
					- 用form表单，action为add_xxx这个url，method为post
					- 点击提交之后client向server发送一个请求
					- server收到请求后回复一个response

		- server
			- 收到a标签跳转的url（get请求响应）
			- 收到add_xxx这个url进入urls中匹配，匹配到就去他对应的视图函数
			- 这个视图函数处理响应的业务逻辑
				- 首先第一次来的时候时GET请求，这个时候应该将add_xxx.html这个页面返回给client
					- return render(request, add_xxx.html)
				- 然后server收到提交的POST请求
					- 从POST请求中拿出client发送来的数据
						- data = request.POST.get("input标签的name")
					- 将数据存入数据库
						- models.tablename.objects.create(字段=data)
					- 将数据库中的结果重新返回（也就是xxx_show。html）
						- return redirect('/xxx_show/')

	- 删
		- client
			- 有一个展示页面（xxx_show.html）
			- 有一个删除按钮（a标签）
				- 点击这个按钮（a标签），client会发送一个get请求，会用a标签的路径去访问server
				- 点击这个a标签（按钮）会跳转到他对应的url('/del_xxx/')
					- 这时需要将这个按钮对应的数据传到server，server才能按照这个数据去删除
					- <a href="/del_xxx/?id={{ i.id }}"><button>del</button></a>
						- ?是一个固定格式，而后面就是一些参数（服务端要用的一些参数）
						- server收到这个参数后就可以按照他进行相应的操作
				- 然后server会返回一个response（这里的业务逻辑在server端）

		- server
			- 收到a标签跳转的url（get请求响应）
			- 收到del_xxx这个url进入urls中匹配，匹配到就去他对应的视图函数
			- 这个视图函数处理响应的业务逻辑
				- 通过client传来的参数来锁定删除的id
					- del_id = request.GET.get("id")
				- 删除数据库中del_id对应的值
					- models.tablename.objects.fileter(id=del_id).delete()
				- 删除成功后返回删除后的页面（'/xxx_show/'）(重定性)
					- return redirect('/xxx_show/')

	- 改
		- client
			- 有一个展示页面（xxx_show.html）
			- 有一个编辑（edit）按钮（a标签）
				- 点击这个按钮（a标签），client会发送一个get请求，会用a标签的路径去访问server
				- 点击这个a标签（按钮）会跳转到他对应的url('/edit_xxx/')
					- 这时需要将这个按钮对应的数据传到server，server才能更改这个数据
					- <a href="/edit_xxx/?id={{ i.id }}"><button>del</button></a>
						- ?是一个固定格式，而后面就是一些参数（服务端要用的一些参数）
						- server收到这个参数后就可以按照他进行相应的操作
				- 然后server会返回一个response（这里的业务逻辑在server端）
			- 第一次发送get请求时会跳转到edit_xxx.html这个页面，这里面是该行对应的数据
			- 第二次发送post请求，这里面会有修改后的数据然后发送给server处理
				- 	<form action="/edit_press/?id={{ result.id }}" method="post">
        				<input type="text" name="updata_name" value="{{ result.name }}">
        				<input type="submit">
    				</form>

    				- input中的数据都是在server查出的数据展现出来的
    				- id是通过点击edit按钮的时候将这个按钮对应的id值记录了下来

				- 处理完后返回原来的xxx_show


		- server
			- 收到a标签跳转的url（get请求响应）
			- 收到edit_xxx这个url进入urls中匹配，匹配到就去他对应的视图函数
			- 这个视图函数处理响应的业务逻辑
				- 第一遍的GET请求
					- 通过client传来的参数来锁定编辑（edit）的id
						- edit_id = request.GET.get("id")
					- 会返回当前编辑行的内容
						- 从数据库中拿出这个值，将这个值展现在edit_xxx.html页面中
							- result = models.tablename.objects.filter(id="")[0]
					- 返回当前编辑的页面
						- return render(request, 'edit_xxx.html', {'resule': result})

				- 第二遍请求是提交数据后的POST请求，
					- form表单中的action为这个编辑页面，
					- 这个页面后面的参数为第一次get请求得到的数据
					- 可以通过GET方法来获取URL上的参数的值

					- 这个时候form表单对应的url来urls中找对应的视图函数
						- 这个视图函数就会执行POST请求的逻辑
						- 用这个新数据把数据库中的旧数据掩盖
							- 获取更改后的值
								- data = request.POST.get("updata_name")
							- 更改数据库中的值
								- 从数据库找到id对应的对象
								- #这里的id就是第一次点击编辑的时候得到的id值（--对应的）
								- new_obj = models.tablename.objects.filter(id='edit_id')[0]
								- new_obj.name = data  #将新的值赋值给数据库中的变量
								- new_obj.save()  #这个事务必须save数据库中的数据才会更改

							- 更改完成后返回，xxx_show页面
								- return redirect('/xxx_show/')



	注意：
		通过GET来获取URL中的值（和请求无关），POST获取表单提交的值。




四、

1、 a标签
	- href属性
		- 相对路径
		- 绝对路径
	- target = "_blank" 跳转到新页面， 不写默认覆盖自己的页面
	- 锚点（同网站标签的跳转（#id名））

2、 

# 出版社
class Press(models.Model):
    id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32)

    def __str__(self):  # print的时候测试使用
        return self.name


# 书
class Book(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32)
    # Django1.1默认就是级联删除，2.0必须指定
    # 可以通过字符串的反射找Press，如果在代码前面就可以直接用，to=关联的表名
    # 外键字段ORM会给他默认加一个_id (加上_id后他的值就是对应关联表的主键值)
    press = models.ForeignKey(to='Press', on_delete=models.CASCADE)
	

- 一对多
	- 一个出版社对应多本书(外键设置在多的一方)
		- 书的属性有一个外键为链接出版社的press_id

书籍的增删改查
	- 增

	- 删

	- 改

	- 查

注意：
    - 增的时候，出版社就是表中的固定出版社，用一个select标签将数据展示，而不是用户自己填
    	<form action="/add_book/" method="post">
          书名：<input type="text" name="book_title">
          <select name="title_name" id="">
            {% for press in data %}
                <option value="{{ press.id }}">
                    {{ press.name }}
                </option>
            {% endfor %}
          </select>
          <input type="submit">
       </form>
    - 改的实时，出版社的内容需要先选定好。需要用模板语言来判断
    	# 这中情况form表单不指定action他默认会提交当前的页面（这是的页面是点击编辑时的页面）
	    <form action="/edit_book/?id={{ data.id }}" method="post">
	        <input type="text" name="title_name" value="{{ data.title }}">
	        <select name="press_name" id="">
	            {% for press in data_list %}
	                {% if data.press == press %}
	                    <option value="{{ press.id }}" selected>
	                    </option>
	                        {{ press.name }}
	                    {% else %}
	                    <option value="{{ press.id }}">
	                        {{ press.name }}
	                    </option>
	                {% endif %}
	            {% endfor %}
	        </select>
	        <input type="submit">
	    </form>


五、
	- 给数据库中已经存在的表添加另外一个字段，ORM不知道如何处理
		- 1） 输入 1 会让用户自己填写一个默认值（在命令行中）
		- 2） 输入 2 自己在ORMclass中指定字段自己加默认值（退出命令行）在modules中修改
				- null = True
				- default = 默认值


1. 多对多关系	
		作者   <-->  书籍
		1. 表结构设计
			1. SQL版
				-- 创建作者表
				create table author(
					id int primary key auto_increment,
					name varchar(32) not null
				);
				
				-- 创建作者和书的关系表
				create table author2book(
					id int primary key auto_increment,
					author_id int not null,
					book_id int not null,
					constraint fk_author foreign key (author_id) references author(id) on delete cascade on update cascade,
					constraint fk_book foreign key (book_id) references book(id) on delete cascade on update cascade
				);

			2. ORM版
				1. 第一版：
					自己创建第三张表
				2. 第二版
					让ORM帮我们创建第三张表
					models.ManyToManyField()
				3. 第三版
					待补充...（ORM进阶操作的时候）			
	2. 作者的增删改查
		1. 查询
			author_obj.books        --> 得到的只是一个关联关系，并不能拿到数据
			author_obj.books.all()  --> 得到和我这个作者关联的所有书籍对象列表
		2. 添加
			1. add()
			
		3. 删除
		
		4. 编辑
			1. 模板语言中
				{% if book in author.books.all %}
			2. ORM编辑多对多
				1. 不能直接操作第三张关系表
				2. 借助ORM给提供的方法
					1. all()
					2. add(id1,id2)
					3. set([id1, id2])
					4. clear()
	3. Django模板语言
		1. for循环
			1. forloop.last
				{% if forloop.last %}
					...
			2. empty
				{% for i in x %}
					...
				{% empty %}
					...
				{% endfor %}
	4. 上传文件
		form表单上传文件
		# 文件的上传
		def index(request):
		    print(request.GET)
		    print(request.POST)
		    print(request.FILES)
		    for item in request.FILES:
		        fileobj = request.FILES.get(item)
		        f = open('upload/%s' % fileobj.name, 'wb')
		        item_file = fileobj.chunks()
		        for line in item_file:
		            f.write(line)
		        f.close()

		    return HttpResponse("成功")

2. 学生管理系统
	- 老师 和 班级 是多对多的关系
